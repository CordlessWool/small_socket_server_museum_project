// Generated by typings
// Source: https://raw.githubusercontent.com/typed-typings/npm-mime/c7c5810698b7eaa421702a53644a8963d372f758/mime.d.ts
declare module '~node-static~mime/mime' {
class Mime {
  types: {
    [extension: string]: string;
  }

  extensions: {
    [extension: string]: string;
  }

  define (map: Map): void;
  load (filename: string): void;
  lookup (path: string, fallback?: string): string;
  extension (mimeType: string): string;
}

interface Map {
  [type: string]: string[];
}

var mime: Mime & {
  default_type: string;
  charsets: {
    lookup (mimeType: string, fallback?: string): string;
  }
  Mime: typeof Mime;
}

export = mime;
}

// Generated by typings
// Source: https://raw.githubusercontent.com/effervescentia/typed-node-static/29ac1643342e18968ecf1a4ce0bca8c0f9055324/index.d.ts
declare module 'node-static' {
import { ServerRequest, ServerResponse } from 'http';
import { Stats } from 'fs';
import mimeType = require('~node-static~mime/mime');

export var mime: typeof mimeType.Mime;
export var version: number[];

export class Server {
  constructor(path?: string, options?: ServerOptions);

  serveFile(filePath: string, status: number, headers: any, request: ServerRequest, response: ServerResponse): void;
  serveDir(dirPath: string, request: ServerRequest, response: ServerResponse, cb: FinishResponse): void;
  servePath(path: string, status: number, headers: any, request: ServerRequest, response: ServerResponse, cb: FinishResponse): void;
  resolve(path: string): void;
  serve(req: ServerRequest, res: ServerResponse, cb?: (err: Error, result: any) => void): void;
  gzipOk(req: ServerRequest, contentType: string): void;
  respondGzip(path: string, status: number, contentType: string, headers: any, files: string[], stat: Stats, req: ServerRequest, res: ServerResponse, finish: FinishResponse): void;
  respondNoGzip(path: string, status: number, contentType: string, headers: any, files: string[], stat: Stats, req: ServerRequest, res: ServerResponse, finish: FinishResponse): void;
  respond(path: string, status: number, headers: any, files: string[], stat: Stats, req: ServerRequest, res: ServerResponse, finish: FinishResponse): void;
  stream(path: string, files: string[], length: number, startByte: number, res: ServerResponse, cb?: (err: Error, offset: number) => void): void;
  parseByteRange(req: ServerRequest, stat: Stats): void;
  finish(status: number, headers: {}, req: ServerRequest, res: ServerResponse, promise: Promise<any>, cb?: (err: Error, result: any) => void): void;
}

interface FinishResponse {
  (status: number, headers: any): void;
}

interface ServerOptions {
  cache?: number;
  serverInfo?: string;
  headers?: any;
  gzip?: boolean | RegExp;
  indexFile?: string;
}
}
